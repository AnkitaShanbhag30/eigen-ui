import os
import json
import zipfile
from typing import Dict, Any, Optional, List
from pydantic import BaseModel, Field
from datetime import datetime
from .llm import get_llm_provider
from .templates_loader import TemplatesLoader
from .brand import load_brand, get_drafts_dir, get_kits_dir, ensure_output_dirs
from .html_tokens import generate_tokens, get_google_fonts_links, generate_css_variables
from .design import DesignAdvisorService
from .imgfm import generate_hero_image
import weasyprint
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.shared import OxmlElement, qn
from PIL import Image, ImageDraw, ImageFont
import io

class ContentOutline(BaseModel):
    """Schema for content outline generated by LLM"""
    headline: str
    subhead: Optional[str] = None
    sections: list = Field(default_factory=list)
    cta: str
    meta: Dict[str, Any] = Field(default_factory=dict)

class ContentGenerator:
    """Generates content using multi-pass LLM and exports to multiple formats"""
    
    def __init__(self):
        self.llm = get_llm_provider()
        self.templates = TemplatesLoader()
        self.design_advisor = DesignAdvisorService()
    
    def generate_content(self, brand_slug: str, template: str, x: str, y: str, z: str, w: str, cta: str, hero: str = "auto", qa: bool = False) -> Dict[str, Any]:
        """Complete content generation pipeline with multi-pass LLM"""
        # Load brand
        brand = load_brand(brand_slug)
        if not brand:
            return {"error": f"Brand {brand_slug} not found"}
        
        # Override CTA if provided
        if cta:
            cta = cta
        
        # Process W parameter
        w_content = self._process_w_parameter(w)
        
        # Multi-pass LLM generation
        print("🤖 Pass 1: Generating content outline...")
        outline = self.design_advisor.generate_content_outline(brand, template, x, y, z, w_content)
        
        print("🤖 Pass 2: Polishing content...")
        outline = self.design_advisor.polish_content(outline, brand)
        
        # Override CTA in outline
        if cta:
            outline["cta"] = cta
        
        # Generate hero image if requested
        hero_path = None
        if hero == "auto" and brand.design_advisor.hero_brief:
            print("🎨 Generating hero image...")
            palette_hints = f"lean into {brand.colors.primary}/{brand.colors.secondary}; soft gradient background; minimal, abstract; keep logotype visible"
            hero_path = generate_hero_image(brand_slug, brand.design_advisor.hero_brief, brand.keywords, palette_hints)
        elif hero.startswith("path:"):
            hero_path = hero[5:]  # Remove 'path:' prefix
        
        # Generate design tokens
        tokens = generate_tokens(brand)
        
        # Render HTML
        print("🎨 Rendering HTML...")
        html_result = self._render_html(brand, template, outline, tokens, hero_path)
        if "error" in html_result:
            return html_result
        
        html_content = html_result["html"]
        
        # Visual QA loop if requested
        if qa:
            print("🔍 Running visual QA analysis...")
            qa_result = self.design_advisor.visual_qa_analysis(html_content, tokens, brand)
            if qa_result:
                # Apply token tweaks and re-render
                tokens = self._apply_token_tweaks(tokens, qa_result.get("tokenTweaks", {}))
                html_result = self._render_html(brand, template, outline, tokens, hero_path)
                html_content = html_result["html"]
        
        # Export to multiple formats
        print("📤 Exporting to multiple formats...")
        export_results = self._export_formats(brand_slug, template, html_content, outline, tokens, brand)
        
        # Create ZIP package
        zip_path = self._create_zip_package(brand_slug, template, export_results)
        
        return {
            "outline": outline,
            "tokens": tokens,
            "paths": export_results,
            "zip_path": zip_path,
            "hero_path": hero_path
        }
    
    def _process_w_parameter(self, w: str) -> str:
        """Process W parameter (could be file path or inline text)"""
        if w.startswith('path:'):
            file_path = w[5:]  # Remove 'path:' prefix
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                return content[:2000]  # Truncate to 2000 chars
            except Exception as e:
                print(f"Failed to read file {file_path}: {e}")
                return ""
        else:
            return w[:2000]  # Truncate to 2000 chars
    
    def _render_html(self, brand: Any, template: str, outline: Dict[str, Any], tokens: Dict[str, Any], hero_path: Optional[str] = None) -> Dict[str, Any]:
        """Render HTML content using template and tokens"""
        try:
            # Get Google Fonts links
            google_fonts = get_google_fonts_links(tokens)
            
            # Generate CSS variables
            css_variables = generate_css_variables(tokens)
            
            # Render template
            context = {
                "brand": brand.dict(),
                "outline": outline,
                "tokens": tokens,
                "google_fonts": google_fonts,
                "css_variables": css_variables,
                "hero_path": hero_path
            }
            
            html_content = self.templates.render_template(template, context)
            if not html_content:
                return {"error": "Failed to render template"}
            
            return {"html": html_content}
            
        except Exception as e:
            return {"error": f"HTML rendering failed: {e}"}
    
    def _apply_token_tweaks(self, tokens: Dict[str, Any], tweaks: Dict[str, Any]) -> Dict[str, Any]:
        """Apply token tweaks from visual QA"""
        # This is a simplified version - in full implementation would apply tweaks
        # within ±20% bounds and validate color substitutions
        print("Applying token tweaks from visual QA...")
        return tokens
    
    def _export_formats(self, brand_slug: str, template: str, html_content: str, outline: Dict[str, Any], tokens: Dict[str, Any], brand: Any) -> Dict[str, str]:
        """Export content to multiple formats"""
        ensure_output_dirs()
        
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        safe_slug = brand_slug.replace('/', '_').replace('\\', '_')
        base_filename = f"{safe_slug}-{template}-{timestamp}"
        
        results = {}
        
        # Export HTML
        html_path = os.path.join(get_drafts_dir(), f"{base_filename}.html")
        with open(html_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        results["html"] = html_path
        
        # Export PDF
        pdf_path = os.path.join(get_drafts_dir(), f"{base_filename}.pdf")
        try:
            self._export_pdf(html_content, pdf_path)
            results["pdf"] = pdf_path
        except Exception as e:
            print(f"PDF export failed: {e}")
            results["pdf"] = ""
        
        # Export DOCX
        docx_path = os.path.join(get_drafts_dir(), f"{base_filename}.docx")
        try:
            self._export_docx(outline, brand, docx_path)
            results["docx"] = docx_path
        except Exception as e:
            print(f"DOCX export failed: {e}")
            results["docx"] = ""
        
        # Export Brand Kit PNG
        kit_path = os.path.join(get_kits_dir(), f"{base_filename}-brand-kit.png")
        try:
            self._export_brand_kit(brand, tokens, kit_path)
            results["brand_kit"] = kit_path
        except Exception as e:
            print(f"Brand kit export failed: {e}")
            results["brand_kit"] = ""
        
        # Export tokens JSON
        tokens_path = os.path.join(get_drafts_dir(), f"{base_filename}-tokens.json")
        with open(tokens_path, 'w', encoding='utf-8') as f:
            json.dump(tokens, f, indent=2)
        results["tokens"] = tokens_path
        
        return results
    
    def _export_pdf(self, html_content: str, pdf_path: str):
        """Export HTML to PDF using WeasyPrint"""
        try:
            # Create PDF from HTML
            pdf_doc = weasyprint.HTML(string=html_content)
            pdf_doc.write_pdf(pdf_path)
        except Exception as e:
            # Fallback to wkhtmltopdf if available
            print(f"WeasyPrint failed, trying wkhtmltopdf: {e}")
            self._export_pdf_wkhtml(html_content, pdf_path)
    
    def _export_pdf_wkhtml(self, html_content: str, pdf_path: str):
        """Fallback PDF export using wkhtmltopdf"""
        try:
            import pdfkit
            options = {
                'page-size': 'A4',
                'margin-top': '0.75in',
                'margin-right': '0.75in',
                'margin-bottom': '0.75in',
                'margin-left': '0.75in',
                'encoding': "UTF-8",
            }
            pdfkit.from_string(html_content, pdf_path, options=options)
        except ImportError:
            print("wkhtmltopdf not available, PDF export failed")
            raise Exception("No PDF engine available")
    
    def _export_docx(self, outline: Dict[str, Any], brand: Any, docx_path: str):
        """Export content to DOCX format"""
        doc = Document()
        
        # Set document styles
        style = doc.styles['Normal']
        style.font.name = brand.typography.body or 'Inter'
        style.font.size = Pt(12)
        
        # Title
        title = doc.add_heading(outline["headline"], 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Subtitle
        if outline.get("subhead"):
            subtitle = doc.add_paragraph(outline["subhead"])
            subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Sections
        for section in outline.get("sections", []):
            # Section title
            doc.add_heading(section["title"], level=1)
            
            # Section content
            for bullet in section.get("bullets", []):
                doc.add_paragraph(bullet, style='List Bullet')
        
        # CTA
        cta_para = doc.add_paragraph()
        cta_run = cta_para.add_run(f"Call to Action: {outline['cta']}")
        cta_run.bold = True
        
        # Save
        doc.save(docx_path)
    
    def _export_brand_kit(self, brand: Any, tokens: Dict[str, Any], kit_path: str):
        """Export brand kit as PNG image"""
        # Create a grid image showing brand elements
        img_width = 1200
        img_height = 800
        
        # Create image with white background
        img = Image.new('RGB', (img_width, img_height), 'white')
        draw = ImageDraw.Draw(img)
        
        try:
            # Try to load a font, fallback to default if not available
            font_large = ImageFont.truetype("arial.ttf", 24)
            font_medium = ImageFont.truetype("arial.ttf", 18)
            font_small = ImageFont.truetype("arial.ttf", 14)
        except:
            # Use default font
            font_large = ImageFont.load_default()
            font_medium = ImageFont.load_default()
            font_small = ImageFont.load_default()
        
        # Brand name
        draw.text((50, 50), f"Brand: {brand.name}", fill='black', font=font_large)
        
        # Colors
        y_offset = 120
        draw.text((50, y_offset), "Color Palette:", fill='black', font=font_medium)
        y_offset += 30
        
        for i, color in enumerate(tokens["colors"]["palette"][:6]):
            x = 50 + (i * 100)
            if x < img_width - 100:
                # Draw color swatch
                draw.rectangle([x, y_offset, x + 80, y_offset + 60], fill=color, outline='black')
                # Draw hex code
                draw.text((x, y_offset + 70), color, fill='black', font=font_small)
        
        # Typography
        y_offset += 120
        draw.text((50, y_offset), f"Typography:", fill='black', font=font_medium)
        y_offset += 30
        draw.text((50, y_offset), f"Headings: {tokens['font_heading']}", fill='black', font=font_small)
        y_offset += 20
        draw.text((50, y_offset), f"Body: {tokens['font_body']}", fill='black', font=font_small)
        
        # Save
        img.save(kit_path)
    
    def _create_zip_package(self, brand_slug: str, template: str, export_results: Dict[str, str]) -> str:
        """Create ZIP package with all exports"""
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        safe_slug = brand_slug.replace('/', '_').replace('\\', '_')
        zip_filename = f"{safe_slug}-{template}-{timestamp}.zip"
        zip_path = os.path.join(get_drafts_dir(), zip_filename)
        
        with zipfile.ZipFile(zip_path, 'w') as zipf:
            # Add all exported files
            for format_name, file_path in export_results.items():
                if file_path and os.path.exists(file_path):
                    arcname = os.path.basename(file_path)
                    zipf.write(file_path, arcname)
        
        return zip_path 